import { INestApplication, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { IoAdapter } from '@nestjs/platform-socket.io';
import { ServerOptions } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import { createClient } from 'redis';

/**
 * PHASE 18: Redis-based Socket.io Adapter for Multi-Instance Clustering
 *
 * Enables horizontal scaling of WebSocket connections across multiple backend instances
 * with shared state through Redis pub/sub and sticky sessions support.
 *
 * Features:
 * - Redis pub/sub for cross-instance event broadcasting
 * - Sticky session support via connection ID hashing
 * - Automatic reconnection with exponential backoff
 * - Connection pool management
 * - Graceful degradation to single-instance mode on Redis failure
 */
export class RedisSocketAdapter extends IoAdapter {
  private readonly logger = new Logger(RedisSocketAdapter.name);
  private adapterConstructor: ReturnType<typeof createAdapter> | null = null;
  private pubClient: any;
  private subClient: any;

  constructor(private app: INestApplication) {
    super(app);
  }

  async connectToRedis(): Promise<void> {
    const configService = this.app.get(ConfigService);
    const redisHost = configService.get('REDIS_HOST', 'localhost');
    const redisPort = configService.get('REDIS_PORT', 6379);
    const redisPassword = configService.get('REDIS_PASSWORD', '');
    const redisDb = configService.get('REDIS_DB', 0);

    this.logger.log(`üîå [REDIS] Connecting to Redis at ${redisHost}:${redisPort}...`);

    try {
      // Create Redis pub client with connection pooling
      this.pubClient = createClient({
        socket: {
          host: redisHost,
          port: redisPort,
          reconnectStrategy: (retries) => {
            // Exponential backoff: 100ms, 200ms, 400ms, ..., max 3s
            const delay = Math.min(100 * Math.pow(2, retries), 3000);
            this.logger.warn(`‚è∞ [REDIS-PUB] Reconnecting in ${delay}ms (attempt ${retries + 1})`);
            return delay;
          },
        },
        password: redisPassword || undefined,
        database: redisDb,
      });

      // Create Redis sub client (separate connection for pub/sub pattern)
      this.subClient = this.pubClient.duplicate();

      // Error handling
      this.pubClient.on('error', (err: Error) => {
        this.logger.error(`‚ùå [REDIS-PUB] Connection error:`, err.message);
      });

      this.subClient.on('error', (err: Error) => {
        this.logger.error(`‚ùå [REDIS-SUB] Connection error:`, err.message);
      });

      // Connection events
      this.pubClient.on('connect', () => {
        this.logger.log('‚úÖ [REDIS-PUB] Connected successfully');
      });

      this.subClient.on('connect', () => {
        this.logger.log('‚úÖ [REDIS-SUB] Connected successfully');
      });

      this.pubClient.on('reconnecting', () => {
        this.logger.warn('üîÑ [REDIS-PUB] Reconnecting...');
      });

      this.subClient.on('reconnecting', () => {
        this.logger.warn('üîÑ [REDIS-SUB] Reconnecting...');
      });

      // Connect to Redis
      await Promise.all([this.pubClient.connect(), this.subClient.connect()]);

      // Create Socket.io Redis adapter
      this.adapterConstructor = createAdapter(this.pubClient, this.subClient, {
        key: 'socket.io',
        requestsTimeout: 5000,
      });

      this.logger.log('üéâ [REDIS] Socket.io Redis adapter initialized successfully');
      this.logger.log('‚úÖ [CLUSTERING] Multi-instance support enabled');
    } catch (error) {
      this.logger.error('‚ùå [REDIS] Failed to connect to Redis:', error.message);
      this.logger.warn('‚ö†Ô∏è [FALLBACK] Running in single-instance mode without Redis clustering');
      this.adapterConstructor = null;
    }
  }

  createIOServer(port: number, options?: ServerOptions): any {
    const configService = this.app.get(ConfigService);
    const allowedOrigins = configService.get('CORS_ORIGINS')
      ? configService.get('CORS_ORIGINS').split(',').map((origin: string) => origin.trim())
      : [
          'http://localhost:3000',
          'http://localhost:3001',
          'http://localhost:3002',
          'http://localhost:3003',
          'http://31.57.166.18:3000',
          'http://31.57.166.18:3001',
          'http://31.57.166.18:3002',
          '*',
        ];

    const server = super.createIOServer(port, {
      ...options,
      cors: {
        origin: allowedOrigins,
        methods: ['GET', 'POST'],
        credentials: true,
      },
      // PHASE 18: Sticky session configuration
      connectionStateRecovery: {
        maxDisconnectionDuration: 2 * 60 * 1000, // 2 minutes
        skipMiddlewares: true,
      },
      // Connection optimization
      allowEIO3: true,
      transports: ['websocket', 'polling'],
      pingTimeout: 60000,
      pingInterval: 25000,
      upgradeTimeout: 10000,
      maxHttpBufferSize: 1e6,
      // PHASE 17: WebSocket compression
      perMessageDeflate: {
        zlibDeflateOptions: {
          chunkSize: 1024,
          memLevel: 7,
          level: 3,
        },
        zlibInflateOptions: {
          chunkSize: 10 * 1024,
        },
        clientNoContextTakeover: true,
        serverNoContextTakeover: true,
        serverMaxWindowBits: 10,
        concurrencyLimit: 10,
        threshold: 1024,
      },
    });

    // Apply Redis adapter if available
    if (this.adapterConstructor) {
      server.adapter(this.adapterConstructor);
      this.logger.log('üîó [CLUSTERING] Redis adapter attached to Socket.io server');
    } else {
      this.logger.warn('‚ö†Ô∏è [SINGLE-INSTANCE] Running without Redis clustering');
    }

    return server;
  }

  /**
   * Graceful shutdown - close Redis connections
   */
  async close(): Promise<void> {
    this.logger.log('üõë [SHUTDOWN] Closing Redis connections...');

    try {
      if (this.pubClient) {
        await this.pubClient.quit();
        this.logger.log('‚úÖ [REDIS-PUB] Connection closed');
      }

      if (this.subClient) {
        await this.subClient.quit();
        this.logger.log('‚úÖ [REDIS-SUB] Connection closed');
      }
    } catch (error) {
      this.logger.error('‚ùå [SHUTDOWN] Error closing Redis connections:', error.message);
    }
  }
}
